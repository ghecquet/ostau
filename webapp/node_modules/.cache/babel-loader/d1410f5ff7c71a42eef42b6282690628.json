{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as React from 'react';\nimport { BaseComponent, classNamesFunction, getId, allowScrollOnElement, KeyCodes } from '../../Utilities';\nimport { FocusTrapZone } from '../FocusTrapZone/index';\nimport { animationDuration } from './Modal.styles';\nimport { Overlay } from '../../Overlay';\nimport { Layer } from '../../Layer';\nimport { Popup } from '../Popup/index';\nimport { withResponsiveMode, ResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { DirectionalHint } from '../Callout/index';\nimport { Icon } from '../Icon/index';\nimport { DraggableZone } from '../../utilities/DraggableZone/index'; // @TODO - need to change this to a panel whenever the breakpoint is under medium (verify the spec)\n\nvar DefaultLayerProps = {\n  eventBubblingEnabled: false\n};\nvar getClassNames = classNamesFunction();\n\nvar ModalBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ModalBase, _super);\n\n  function ModalBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._focusTrapZone = React.createRef(); // Allow the user to scroll within the modal but not on the body\n\n    _this._allowScrollOnModal = function (elt) {\n      if (elt) {\n        allowScrollOnElement(elt, _this._events);\n      } else {\n        _this._events.off(_this._scrollableContent);\n      }\n\n      _this._scrollableContent = elt;\n    };\n\n    _this._onModalContextMenuClose = function () {\n      _this.setState({\n        isModalMenuOpen: false\n      });\n    };\n\n    _this._onModalClose = function () {\n      _this._lastSetX = 0;\n      _this._lastSetY = 0;\n\n      _this.setState({\n        isModalMenuOpen: false,\n        isInKeyboardMoveMode: false,\n        isOpen: false,\n        x: 0,\n        y: 0\n      }); // Call the onDismiss callback\n\n\n      if (_this.props.onDismissed) {\n        _this.props.onDismissed();\n      }\n    };\n\n    _this._onDragStart = function () {\n      _this.setState({\n        isModalMenuOpen: false,\n        isInKeyboardMoveMode: false\n      });\n    };\n\n    _this._onDrag = function (_, ui) {\n      var _a = _this.state,\n          x = _a.x,\n          y = _a.y;\n\n      _this.setState({\n        x: x + ui.delta.x,\n        y: y + ui.delta.y\n      });\n    };\n\n    _this._onDragStop = function () {\n      _this.focus();\n    };\n\n    _this._onDialogKeyUp = function (event) {\n      // Need to handle the CTRL + ALT + SPACE key during keyup due to FireFox bug:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1220143\n      // Otherwise it would continue to fire a click even if the event was cancelled\n      // during mouseDown.\n      if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n        _this.setState({\n          isModalMenuOpen: !_this.state.isModalMenuOpen\n        });\n\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    };\n\n    _this._onDialogKeyDown = function (event) {\n      if (event.altKey && event.ctrlKey && event.keyCode === KeyCodes.space) {\n        // CTRL + ALT + SPACE is handled during keyUp\n        event.preventDefault();\n        event.stopPropagation();\n        return;\n      }\n\n      if (_this.state.isModalMenuOpen && (event.altKey || event.keyCode === KeyCodes.escape)) {\n        _this.setState({\n          isModalMenuOpen: false\n        });\n      }\n\n      if (_this.state.isInKeyboardMoveMode && (event.keyCode === KeyCodes.escape || event.keyCode === KeyCodes.enter)) {\n        _this.setState({\n          isInKeyboardMoveMode: false\n        });\n\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.state.isInKeyboardMoveMode) {\n        var handledEvent = true;\n\n        var delta = _this._getMoveDelta(event);\n\n        switch (event.keyCode) {\n          case KeyCodes.escape:\n            _this.setState({\n              x: _this._lastSetX,\n              y: _this._lastSetY\n            });\n\n          case KeyCodes.enter:\n            {\n              _this._lastSetX = 0;\n              _this._lastSetY = 0;\n\n              _this.setState({\n                isInKeyboardMoveMode: false\n              });\n\n              break;\n            }\n\n          case KeyCodes.up:\n            {\n              _this.setState({\n                y: _this.state.y - delta\n              });\n\n              break;\n            }\n\n          case KeyCodes.down:\n            {\n              _this.setState({\n                y: _this.state.y + delta\n              });\n\n              break;\n            }\n\n          case KeyCodes.left:\n            {\n              _this.setState({\n                x: _this.state.x - delta\n              });\n\n              break;\n            }\n\n          case KeyCodes.right:\n            {\n              _this.setState({\n                x: _this.state.x + delta\n              });\n\n              break;\n            }\n\n          default:\n            {\n              handledEvent = false;\n            }\n        }\n\n        if (handledEvent) {\n          event.preventDefault();\n          event.stopPropagation();\n        }\n      }\n    };\n\n    _this._onEnterKeyboardMoveMode = function () {\n      _this._lastSetX = _this.state.x;\n      _this._lastSetY = _this.state.y;\n\n      _this.setState({\n        isInKeyboardMoveMode: true,\n        isModalMenuOpen: false\n      });\n    };\n\n    _this._onExitKeyboardMoveMode = function () {\n      _this._lastSetX = 0;\n      _this._lastSetY = 0;\n\n      _this.setState({\n        isInKeyboardMoveMode: false\n      });\n    };\n\n    _this.state = {\n      id: getId('Modal'),\n      isOpen: props.isOpen,\n      isVisible: props.isOpen,\n      hasBeenOpened: props.isOpen,\n      x: 0,\n      y: 0\n    };\n    _this._lastSetX = 0;\n    _this._lastSetY = 0;\n\n    _this._warnDeprecations({\n      onLayerDidMount: 'layerProps.onLayerDidMount'\n    });\n\n    return _this;\n  }\n\n  ModalBase.prototype.componentWillReceiveProps = function (newProps) {\n    clearTimeout(this._onModalCloseTimer); // Opening the dialog\n\n    if (newProps.isOpen) {\n      if (!this.state.isOpen) {\n        // First Open\n        this.setState({\n          isOpen: true\n        });\n      } else {\n        // Modal has been opened\n        // Reopen during closing\n        this.setState({\n          hasBeenOpened: true,\n          isVisible: true\n        });\n\n        if (newProps.topOffsetFixed) {\n          var dialogMain = document.getElementsByClassName('ms-Dialog-main');\n          var modalRectangle = void 0;\n\n          if (dialogMain.length > 0) {\n            modalRectangle = dialogMain[0].getBoundingClientRect();\n            this.setState({\n              modalRectangleTop: modalRectangle.top\n            });\n          }\n        }\n      }\n    } // Closing the dialog\n\n\n    if (!newProps.isOpen && this.state.isOpen) {\n      this._onModalCloseTimer = this._async.setTimeout(this._onModalClose, parseFloat(animationDuration) * 1000);\n      this.setState({\n        isVisible: false\n      });\n    }\n  };\n\n  ModalBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (!prevProps.isOpen && !prevState.isVisible) {\n      this.setState({\n        isVisible: true\n      });\n    }\n  };\n\n  ModalBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        containerClassName = _a.containerClassName,\n        scrollableContentClassName = _a.scrollableContentClassName,\n        elementToFocusOnDismiss = _a.elementToFocusOnDismiss,\n        firstFocusableSelector = _a.firstFocusableSelector,\n        forceFocusInsideTrap = _a.forceFocusInsideTrap,\n        ignoreExternalFocusing = _a.ignoreExternalFocusing,\n        isBlocking = _a.isBlocking,\n        isClickableOutsideFocusTrap = _a.isClickableOutsideFocusTrap,\n        isDarkOverlay = _a.isDarkOverlay,\n        onDismiss = _a.onDismiss,\n        layerProps = _a.layerProps,\n        responsiveMode = _a.responsiveMode,\n        titleAriaId = _a.titleAriaId,\n        styles = _a.styles,\n        subtitleAriaId = _a.subtitleAriaId,\n        theme = _a.theme,\n        topOffsetFixed = _a.topOffsetFixed,\n        onLayerDidMount = _a.onLayerDidMount,\n        isModeless = _a.isModeless,\n        dragOptions = _a.dragOptions;\n    var _b = this.state,\n        isOpen = _b.isOpen,\n        isVisible = _b.isVisible,\n        hasBeenOpened = _b.hasBeenOpened,\n        modalRectangleTop = _b.modalRectangleTop,\n        x = _b.x,\n        y = _b.y,\n        isInKeyboardMoveMode = _b.isInKeyboardMoveMode;\n\n    if (!isOpen) {\n      return null;\n    }\n\n    var layerClassName = layerProps === undefined ? '' : layerProps.className;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      containerClassName: containerClassName,\n      scrollableContentClassName: scrollableContentClassName,\n      isOpen: isOpen,\n      isVisible: isVisible,\n      hasBeenOpened: hasBeenOpened,\n      modalRectangleTop: modalRectangleTop,\n      topOffsetFixed: topOffsetFixed,\n      isModeless: isModeless,\n      layerClassName: layerClassName,\n      isDefaultDragHandle: dragOptions && !dragOptions.dragHandleSelector\n    });\n\n    var mergedLayerProps = tslib_1.__assign({}, DefaultLayerProps, this.props.layerProps, {\n      onLayerDidMount: layerProps && layerProps.onLayerDidMount ? layerProps.onLayerDidMount : onLayerDidMount,\n      insertFirst: isModeless,\n      className: classNames.layer\n    });\n\n    var modalContent = React.createElement(FocusTrapZone, {\n      componentRef: this._focusTrapZone,\n      className: classNames.main,\n      elementToFocusOnDismiss: elementToFocusOnDismiss,\n      isClickableOutsideFocusTrap: isModeless || isClickableOutsideFocusTrap || !isBlocking,\n      ignoreExternalFocusing: ignoreExternalFocusing,\n      forceFocusInsideTrap: isModeless ? !isModeless : forceFocusInsideTrap,\n      firstFocusableSelector: firstFocusableSelector,\n      focusPreviouslyFocusedInnerElement: true,\n      onKeyDown: dragOptions ? this._onDialogKeyDown : undefined,\n      onKeyUp: dragOptions ? this._onDialogKeyUp : undefined,\n      onBlur: isInKeyboardMoveMode ? this._onExitKeyboardMoveMode : undefined\n    }, dragOptions && isInKeyboardMoveMode && React.createElement(\"div\", {\n      className: classNames.keyboardMoveIconContainer\n    }, dragOptions.keyboardMoveIconProps ? React.createElement(Icon, tslib_1.__assign({}, dragOptions.keyboardMoveIconProps)) : React.createElement(Icon, {\n      iconName: \"move\",\n      className: classNames.keyboardMoveIcon\n    })), React.createElement(\"div\", {\n      ref: this._allowScrollOnModal,\n      className: classNames.scrollableContent,\n      \"data-is-scrollable\": true\n    }, dragOptions && this.state.isModalMenuOpen && React.createElement(dragOptions.menu, {\n      items: [{\n        key: 'move',\n        text: dragOptions.moveMenuItemText,\n        onClick: this._onEnterKeyboardMoveMode\n      }, {\n        key: 'close',\n        text: dragOptions.closeMenuItemText,\n        onClick: this._onModalClose\n      }],\n      onDismiss: this._onModalContextMenuClose,\n      alignTargetEdge: true,\n      coverTarget: true,\n      directionalHint: DirectionalHint.topLeftEdge,\n      directionalHintFixed: true,\n      shouldFocusOnMount: true,\n      target: this._scrollableContent\n    }), this.props.children)); // @temp tuatology - Will adjust this to be a panel at certain breakpoints\n\n    if (responsiveMode >= ResponsiveMode.small) {\n      return React.createElement(Layer, tslib_1.__assign({}, mergedLayerProps), React.createElement(Popup, {\n        role: isModeless || !isBlocking ? 'dialog' : 'alertdialog',\n        \"aria-modal\": !isModeless,\n        ariaLabelledBy: titleAriaId,\n        ariaDescribedBy: subtitleAriaId,\n        onDismiss: onDismiss\n      }, React.createElement(\"div\", {\n        className: classNames.root\n      }, !isModeless && React.createElement(Overlay, {\n        isDarkThemed: isDarkOverlay,\n        onClick: isBlocking ? undefined : onDismiss\n      }), dragOptions ? React.createElement(DraggableZone, {\n        handleSelector: dragOptions.dragHandleSelector || \".\" + classNames.main.split(' ')[0],\n        preventDragSelector: \"button\",\n        onStart: this._onDragStart,\n        onDragChange: this._onDrag,\n        onStop: this._onDragStop,\n        position: {\n          x: x,\n          y: y\n        }\n      }, modalContent) : modalContent)));\n    }\n\n    return null;\n  };\n\n  ModalBase.prototype.focus = function () {\n    if (this._focusTrapZone.current) {\n      this._focusTrapZone.current.focus();\n    }\n  };\n\n  ModalBase.prototype._getMoveDelta = function (event) {\n    var delta = 10;\n\n    if (event.shiftKey) {\n      if (!event.ctrlKey) {\n        delta = 50;\n      }\n    } else if (event.ctrlKey) {\n      delta = 1;\n    }\n\n    return delta;\n  };\n\n  ModalBase.defaultProps = {\n    isOpen: false,\n    isDarkOverlay: true,\n    isBlocking: false,\n    className: '',\n    containerClassName: ''\n  };\n  ModalBase = tslib_1.__decorate([withResponsiveMode], ModalBase);\n  return ModalBase;\n}(BaseComponent);\n\nexport { ModalBase };","map":null,"metadata":{},"sourceType":"module"}