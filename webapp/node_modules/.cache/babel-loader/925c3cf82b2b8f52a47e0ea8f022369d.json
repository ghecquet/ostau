{"ast":null,"code":"\"use strict\";\n\nvar SEPARATOR = \"/\";\nvar SINGLE = \"+\";\nvar ALL = \"#\";\nmodule.exports = {\n  matches: matches,\n  extract: extract,\n  exec: exec,\n  fill: fill,\n  clean: clean\n};\n\nfunction exec(pattern, topic) {\n  return matches(pattern, topic) ? extract(pattern, topic) : null;\n}\n\nfunction matches(pattern, topic) {\n  var patternSegments = pattern.split(SEPARATOR);\n  var topicSegments = topic.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n  var topicLength = topicSegments.length;\n  var lastIndex = patternLength - 1;\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n    var currentTopic = topicSegments[i];\n    if (!currentTopic && !currentPattern) continue;\n    if (!currentTopic && currentPattern !== ALL) return false; // Only allow # at end\n\n    if (patternChar === ALL) return i === lastIndex;\n    if (patternChar !== SINGLE && currentPattern !== currentTopic) return false;\n  }\n\n  return patternLength === topicLength;\n}\n\nfunction fill(pattern, params) {\n  var patternSegments = pattern.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n  var result = [];\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n    var patternParam = currentPattern.slice(1);\n    var paramValue = params[patternParam];\n\n    if (patternChar === ALL) {\n      // Check that it isn't undefined\n      if (paramValue !== void 0) result.push([].concat(paramValue).join(SEPARATOR)); // Ensure it's an array\n      // Since # wildcards are always at the end, break out of the loop\n\n      break;\n    } else if (patternChar === SINGLE) // Coerce param into a string, missing params will be undefined\n      result.push(\"\" + paramValue);else result.push(currentPattern);\n  }\n\n  return result.join(SEPARATOR);\n}\n\nfunction extract(pattern, topic) {\n  var params = {};\n  var patternSegments = pattern.split(SEPARATOR);\n  var topicSegments = topic.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n    if (currentPattern.length === 1) continue;\n\n    if (patternChar === ALL) {\n      params[currentPattern.slice(1)] = topicSegments.slice(i);\n      break;\n    } else if (patternChar === SINGLE) {\n      params[currentPattern.slice(1)] = topicSegments[i];\n    }\n  }\n\n  return params;\n}\n\nfunction clean(pattern) {\n  var patternSegments = pattern.split(SEPARATOR);\n  var patternLength = patternSegments.length;\n  var cleanedSegments = [];\n\n  for (var i = 0; i < patternLength; i++) {\n    var currentPattern = patternSegments[i];\n    var patternChar = currentPattern[0];\n\n    if (patternChar === ALL) {\n      cleanedSegments.push(ALL);\n    } else if (patternChar === SINGLE) {\n      cleanedSegments.push(SINGLE);\n    } else {\n      cleanedSegments.push(currentPattern);\n    }\n  }\n\n  return cleanedSegments.join('/');\n}","map":null,"metadata":{},"sourceType":"script"}